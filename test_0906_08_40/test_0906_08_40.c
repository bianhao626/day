#include <stdio.h>
#include <stdlib.h>
int minNumberDisappeared(int* nums, int numsLen)
{
    int* arr = malloc(sizeof(int) * numsLen);
    int j = 0;
    for (int i = 0; i < numsLen; i++)
    {
        arr[i] = 0;
    }
    for (int i = 0; i < numsLen; i++)
    {
        if (nums[i] > 0 && nums[i] <= numsLen)
        {
            arr[nums[i] - 1] = 1;
        }
    }
    for (j = 0; j < numsLen; j++)
    {
        if (arr[j] == 0)
        {
            break;
        }
    }
    return j + 1;
}
int main()
{
    int nums[] = { 3,2,1 };
    int ret = minNumberDisappeared(nums, 3);
    printf("%d", ret);
    return 0;
}
/*
给定一个无重复元素的整数数组nums，请你找出其中没有出现的最小的正整数
案例1、[1,0,2]、3
案例2、[-2,3,4,1,5]、2
案例3、[4,5,6,8,9]、1
*/
/*
巧妙的思想方式，首先我们要弄清楚一个问题，那就是如何遍历一次就可以得到结果
最容易想到的就是使用哈希数组存储对应的正整数元素，然后再遍历哈希数组找到对应的最小正整数
*/
/*
显然，如果数据足够大，那么我们创建的哈希数组就要非常大，这显然是会出现栈溢出的问题
所以，我们换一种思路，观察例子其实不难看出，要找的是最小的正整数，也就表示肯定是要从1开始寻找
那么我们创建一个和原数组大小一样的数组作为哈希数组可以吗？
答案是可以的，只不过和无穷大哈希数组相比，再进行标记的时候需要多一步判断
是否数据在哈希数组中有映射
（这里要注意，如果没有映射，那就说明，我们数组中的任何一个数，都比这个数小
那么我们就不需要考虑这个数了。相反有映射，我们记录下来即可）
之后，遍历哈希数组即可，找到第一个没有标记的元素，就是我们要找的最小元素
*/
/*
可能会出现的几种情况：
第一种全部没有标记：这种情况就是案例三，这样第一个元素就是缺少的最小正整数
第二种情况部分标记：这种情况通过遍历，就可以找到缺少的最小正整数
第三种情况全部标记：（注意此时我们所有已经标记了原数组中所有的正整数元素），所以原数组最大元素加一就是我们要找的元素
*/
